# 渲染引擎服务器部署配置指南

更新时间：2026-02-19

本文档详细说明服务器部署动画渲染引擎所需的配置和依赖。

## 一、系统要求

### 1.1 基础环境
- **操作系统**：Linux (推荐 Ubuntu 20.04+ / CentOS 7+) 或 Windows Server
- **PHP版本**：PHP 8.1+（推荐 PHP 8.2）
- **内存**：最低 4GB，推荐 8GB+（Blender渲染需要更多内存）
- **CPU**：多核CPU，推荐 4核+（渲染是CPU密集型任务）
- **磁盘空间**：至少 50GB 可用空间（用于存储渲染输出和临时文件）

### 1.2 PHP扩展要求

#### 必需扩展
```bash
# 检查已安装的扩展
php -m | grep -E "gd|curl|json|zip|fileinfo"
```

- ✅ **gd**：用于生成单帧图像（必需）
- ✅ **curl**：用于云渲染API调用（必需）
- ✅ **json**：用于数据处理（通常已内置）
- ✅ **zip**：用于文件压缩（推荐）
- ✅ **fileinfo**：用于文件类型检测（推荐）

#### 安装PHP扩展（Ubuntu/Debian）
```bash
# 安装GD库及其依赖
sudo apt-get update
sudo apt-get install -y php-gd php-curl php-zip php-fileinfo

# 如果使用PHP-FPM，重启服务
sudo systemctl restart php8.2-fpm  # 根据实际PHP版本调整
```

#### 安装PHP扩展（CentOS/RHEL）
```bash
# 安装GD库及其依赖
sudo yum install -y php-gd php-curl php-zip php-fileinfo

# 重启PHP-FPM
sudo systemctl restart php-fpm
```

#### 验证GD库安装
```php
<?php
if (function_exists('imagecreatetruecolor')) {
    echo "GD库已安装 ✓\n";
} else {
    echo "GD库未安装 ✗\n";
}
```

## 二、FFmpeg 安装和配置

### 2.1 安装FFmpeg

#### Ubuntu/Debian
```bash
# 方法1：使用apt安装（可能版本较旧）
sudo apt-get update
sudo apt-get install -y ffmpeg

# 方法2：使用snap安装（推荐，版本较新）
sudo snap install ffmpeg

# 方法3：从源码编译（最新版本）
# 参考：https://ffmpeg.org/download.html
```

#### CentOS/RHEL
```bash
# 启用EPEL仓库
sudo yum install -y epel-release

# 安装FFmpeg
sudo yum install -y ffmpeg ffmpeg-devel

# 或者使用RPM Fusion仓库
sudo yum install --nogpgcheck https://download1.rpmfusion.org/free/el/rpmfusion-free-release-8.noarch.rpm
sudo yum install -y ffmpeg
```

#### Windows
```bash
# 下载FFmpeg二进制文件
# https://ffmpeg.org/download.html#build-windows

# 解压到 C:\ffmpeg
# 添加到系统PATH环境变量
```

### 2.2 配置FFmpeg路径（可选）

如果FFmpeg不在系统PATH中，可以通过环境变量指定：

```bash
# Linux - 添加到 ~/.bashrc 或 /etc/environment
export FFMPEG_PATH=/usr/bin/ffmpeg

# Windows - 添加到系统环境变量
set FFMPEG_PATH=C:\ffmpeg\bin\ffmpeg.exe
```

### 2.3 验证FFmpeg安装
```bash
ffmpeg -version
# 应该显示FFmpeg版本信息
```

## 三、Blender 安装和配置（可选）

### 3.1 安装Blender

#### Ubuntu/Debian
```bash
# 方法1：使用snap安装（推荐）
sudo snap install blender --classic

# 方法2：从官方PPA安装
sudo add-apt-repository ppa:thomas-schiex/blender
sudo apt-get update
sudo apt-get install -y blender

# 方法3：下载官方二进制包
wget https://download.blender.org/release/Blender3.6/blender-3.6.5-linux-x64.tar.xz
tar -xf blender-3.6.5-linux-x64.tar.xz
sudo mv blender-3.6.5-linux-x64 /opt/blender
sudo ln -s /opt/blender/blender /usr/local/bin/blender
```

#### CentOS/RHEL
```bash
# 下载官方二进制包
wget https://download.blender.org/release/Blender3.6/blender-3.6.5-linux-x64.tar.xz
tar -xf blender-3.6.5-linux-x64.tar.xz
sudo mv blender-3.6.5-linux-x64 /opt/blender
sudo ln -s /opt/blender/blender /usr/local/bin/blender
```

#### Windows
```bash
# 下载Windows安装包
# https://www.blender.org/download/

# 安装后添加到系统PATH，或设置环境变量
set BLENDER_PATH=C:\Program Files\Blender Foundation\Blender\blender.exe
```

### 3.2 配置Blender路径（可选）

如果Blender不在系统PATH中：

```bash
# Linux
export BLENDER_PATH=/usr/bin/blender
# 或
export BLENDER_PATH=/opt/blender/blender

# Windows
set BLENDER_PATH=C:\Program Files\Blender Foundation\Blender\blender.exe
```

### 3.3 验证Blender安装
```bash
blender --version
# 应该显示Blender版本信息
```

### 3.4 Blender Python依赖（如果需要）

Blender通常自带Python，但如果需要额外的Python包：

```bash
# 使用Blender自带的Python
/opt/blender/3.6/python/bin/python3.10 -m pip install <package>
```

## 四、云渲染服务配置（可选）

### 4.1 AWS Batch 配置

```bash
# 安装AWS CLI
pip install awscli

# 配置AWS凭证
aws configure

# 设置环境变量
export AWS_ACCESS_KEY_ID=your_access_key
export AWS_SECRET_ACCESS_KEY=your_secret_key
export AWS_DEFAULT_REGION=us-east-1
```

在 `render_settings` 中配置：
```json
{
  "custom_engine_type": "aws",
  "custom_engine_config": {
    "access_key": "your_access_key",
    "secret_key": "your_secret_key",
    "region": "us-east-1",
    "job_queue": "render-queue",
    "job_definition": "render-job"
  }
}
```

### 4.2 Google Cloud Render 配置

```bash
# 安装Google Cloud SDK
# https://cloud.google.com/sdk/docs/install

# 配置认证
gcloud auth login
gcloud config set project YOUR_PROJECT_ID
```

在 `render_settings` 中配置：
```json
{
  "custom_engine_type": "gcp",
  "custom_engine_config": {
    "project_id": "your-project-id",
    "service_account_key": "/path/to/service-account-key.json"
  }
}
```

### 4.3 通用云渲染API配置

在 `render_settings` 中配置：
```json
{
  "custom_engine_type": "cloud",
  "custom_engine_config": {
    "api_endpoint": "https://api.render-service.com",
    "api_key": "your_api_key"
  }
}
```

## 五、目录权限配置

### 5.1 创建渲染输出目录

```bash
# 创建基础目录
sudo mkdir -p /var/www/html/public/uploads/anime_renders
sudo chown -R www-data:www-data /var/www/html/public/uploads/anime_renders
sudo chmod -R 755 /var/www/html/public/uploads/anime_renders

# 如果使用Docker，确保目录可写
docker exec -it container_name chown -R www-data:www-data /var/www/html/public/uploads/anime_renders
```

### 5.2 PHP执行权限

确保PHP可以执行系统命令：

```php
// 检查exec函数是否可用
if (function_exists('exec')) {
    echo "exec函数可用 ✓\n";
} else {
    echo "exec函数被禁用 ✗\n";
}
```

如果被禁用，修改 `php.ini`：
```ini
disable_functions =  # 移除exec, shell_exec等
```

### 5.3 临时文件目录

```bash
# 设置PHP临时目录权限
sudo chmod 1777 /tmp

# 或在php.ini中配置
upload_tmp_dir = /var/www/tmp
```

## 六、PHP配置优化

### 6.1 内存限制

编辑 `php.ini`：
```ini
memory_limit = 512M  # 渲染需要较多内存，建议512M+
```

### 6.2 执行时间限制

```ini
max_execution_time = 300  # 渲染可能需要较长时间，建议300秒+
```

### 6.3 文件上传限制

```ini
upload_max_filesize = 100M
post_max_size = 100M
```

### 6.4 进程管理（PHP-FPM）

编辑 `/etc/php/8.2/fpm/pool.d/www.conf`：
```ini
pm = dynamic
pm.max_children = 20
pm.start_servers = 5
pm.min_spare_servers = 5
pm.max_spare_servers = 10
pm.max_requests = 500
```

## 七、性能优化建议

### 7.1 使用队列系统（推荐）

对于大量渲染任务，建议使用队列系统：

```bash
# 安装Redis（如果还没有）
sudo apt-get install -y redis-server

# 使用队列处理渲染任务
# 参考：app/services/QueueService.php
```

### 7.2 异步渲染

将渲染任务放入队列，避免阻塞Web请求：

```php
// 示例：异步提交渲染任务
$queueService->push('render_animation', [
    'animation_id' => $animationId,
    'render_engine' => 'ffmpeg',
    'quality' => 'medium'
]);
```

### 7.3 缓存策略

- 缓存已渲染的帧序列
- 使用Redis缓存渲染结果
- 实现渲染结果CDN加速

### 7.4 资源监控

```bash
# 监控CPU和内存使用
htop

# 监控磁盘空间
df -h

# 监控渲染进程
ps aux | grep -E "ffmpeg|blender"
```

## 八、安全配置

### 8.1 文件权限

```bash
# 确保上传目录有正确的权限
chmod 755 /var/www/html/public/uploads/anime_renders
chown www-data:www-data /var/www/html/public/uploads/anime_renders
```

### 8.2 输入验证

确保渲染参数经过验证：
- 动画ID必须是有效的整数
- 质量参数必须是允许的值（low/medium/high/ultra）
- 输出格式必须是允许的格式（mp4/avi/mov等）

### 8.3 命令注入防护

代码中已使用 `escapeshellarg()` 防止命令注入，确保：
- 所有用户输入都经过转义
- 不要直接拼接用户输入到命令中

## 九、故障排查

### 9.1 FFmpeg不可用

```bash
# 检查FFmpeg是否在PATH中
which ffmpeg

# 检查FFmpeg版本
ffmpeg -version

# 如果不在PATH中，设置环境变量
export FFMPEG_PATH=/usr/bin/ffmpeg
```

### 9.2 Blender不可用

```bash
# 检查Blender是否在PATH中
which blender

# 检查Blender版本
blender --version

# 如果不在PATH中，设置环境变量
export BLENDER_PATH=/usr/bin/blender
```

### 9.3 GD库不可用

```bash
# 检查GD库是否安装
php -m | grep gd

# 检查GD库功能
php -r "var_dump(function_exists('imagecreatetruecolor'));"
```

### 9.4 权限问题

```bash
# 检查目录权限
ls -la /var/www/html/public/uploads/anime_renders

# 检查PHP进程用户
ps aux | grep php-fpm

# 确保PHP用户有写入权限
sudo chown -R www-data:www-data /var/www/html/public/uploads/anime_renders
```

### 9.5 内存不足

```bash
# 检查内存使用
free -h

# 增加PHP内存限制
# 编辑 php.ini: memory_limit = 1024M
```

## 十、Docker部署配置

### 10.1 Dockerfile示例

```dockerfile
FROM php:8.2-fpm

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    ffmpeg \
    git \
    unzip \
    libzip-dev \
    libpng-dev \
    libjpeg-dev \
    libfreetype6-dev \
    && docker-php-ext-configure gd --with-freetype --with-jpeg \
    && docker-php-ext-install gd zip curl fileinfo \
    && apt-get clean

# 安装Blender（可选）
RUN wget https://download.blender.org/release/Blender3.6/blender-3.6.5-linux-x64.tar.xz \
    && tar -xf blender-3.6.5-linux-x64.tar.xz \
    && mv blender-3.6.5-linux-x64 /opt/blender \
    && ln -s /opt/blender/blender /usr/local/bin/blender \
    && rm blender-3.6.5-linux-x64.tar.xz

# 设置环境变量
ENV FFMPEG_PATH=/usr/bin/ffmpeg
ENV BLENDER_PATH=/usr/local/bin/blender

# 创建渲染输出目录
RUN mkdir -p /var/www/html/public/uploads/anime_renders \
    && chown -R www-data:www-data /var/www/html/public/uploads/anime_renders

WORKDIR /var/www/html
```

### 10.2 docker-compose.yml示例

```yaml
version: '3.8'

services:
  app:
    build: .
    volumes:
      - ./public/uploads/anime_renders:/var/www/html/public/uploads/anime_renders
    environment:
      - FFMPEG_PATH=/usr/bin/ffmpeg
      - BLENDER_PATH=/usr/local/bin/blender
    deploy:
      resources:
        limits:
          memory: 4G
        reservations:
          memory: 2G
```

## 十一、检查清单

部署前请确认：

- [ ] PHP 8.1+ 已安装
- [ ] GD扩展已安装并启用
- [ ] FFmpeg已安装并在PATH中
- [ ] Blender已安装（如需要）
- [ ] 渲染输出目录已创建并有写权限
- [ ] PHP内存限制已设置为512M+
- [ ] PHP执行时间限制已设置为300秒+
- [ ] exec函数未被禁用
- [ ] 环境变量已正确设置（如需要）
- [ ] 云渲染服务凭证已配置（如需要）

## 十二、测试验证

创建测试脚本验证配置：

```php
<?php
// test_render_config.php

echo "=== 渲染引擎配置检查 ===\n\n";

// 检查PHP版本
echo "PHP版本: " . PHP_VERSION . "\n";

// 检查GD库
if (function_exists('imagecreatetruecolor')) {
    echo "✓ GD库已安装\n";
} else {
    echo "✗ GD库未安装\n";
}

// 检查FFmpeg
$ffmpegPath = getenv('FFMPEG_PATH') ?: 'ffmpeg';
exec("$ffmpegPath -version 2>&1", $output, $returnCode);
if ($returnCode === 0) {
    echo "✓ FFmpeg已安装: " . $output[0] . "\n";
} else {
    echo "✗ FFmpeg未安装或不可用\n";
}

// 检查Blender
$blenderPath = getenv('BLENDER_PATH') ?: 'blender';
exec("$blenderPath --version 2>&1", $output, $returnCode);
if ($returnCode === 0) {
    echo "✓ Blender已安装: " . $output[0] . "\n";
} else {
    echo "✗ Blender未安装或不可用（可选）\n";
}

// 检查目录权限
$renderDir = dirname(__DIR__) . '/public/uploads/anime_renders';
if (is_writable($renderDir)) {
    echo "✓ 渲染输出目录可写\n";
} else {
    echo "✗ 渲染输出目录不可写: $renderDir\n";
}

// 检查exec函数
if (function_exists('exec')) {
    echo "✓ exec函数可用\n";
} else {
    echo "✗ exec函数被禁用\n";
}

echo "\n=== 检查完成 ===\n";
```

运行测试：
```bash
php test_render_config.php
```

## 十三、常见问题

### Q1: FFmpeg命令执行失败
**A**: 检查FFmpeg是否在PATH中，或设置 `FFMPEG_PATH` 环境变量。

### Q2: Blender渲染超时
**A**: 增加PHP执行时间限制，或使用队列异步处理。

### Q3: 内存不足错误
**A**: 增加PHP内存限制（`memory_limit`），或使用云渲染服务。

### Q4: 权限被拒绝
**A**: 确保PHP进程用户（通常是www-data）对渲染输出目录有写权限。

### Q5: GD库图像生成失败
**A**: 检查GD库是否正确安装，确保支持PNG格式。

---

**注意**：生产环境建议使用队列系统处理渲染任务，避免长时间阻塞Web请求。对于大量渲染任务，考虑使用专门的渲染服务器或云渲染服务。
