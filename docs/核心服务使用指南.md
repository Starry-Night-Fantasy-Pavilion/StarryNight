# 核心服务使用指南

本文档介绍如何使用项目中已实现的核心服务：统一错误码体系、CSRF/XSS安全防护、事件系统和消息队列服务。

## 目录

1. [统一错误码体系](#统一错误码体系)
2. [CSRF/XSS安全防护](#csrfxss安全防护)
3. [事件系统](#事件系统)
4. [消息队列服务](#消息队列服务)

---

## 统一错误码体系

### 概述

错误码体系位于 `core/Exceptions/` 目录，提供统一的错误码定义和异常处理。

### 错误码格式

```
6位数字：前两位模块代码 + 中两位业务代码 + 后两位具体错误代码
```

### 使用示例

```php
use Core\Exceptions\ErrorCode;
use Core\Exceptions\AppException;

// 获取错误消息
$message = ErrorCode::getMessage(ErrorCode::AUTH_FAILED);

// 获取HTTP状态码
$httpStatus = ErrorCode::getHttpStatus(ErrorCode::AUTH_FAILED);

// 格式化错误响应
$response = ErrorCode::formatResponse(
    ErrorCode::VALIDATION_FAILED,
    '用户名不能为空',
    ['field' => 'username']
);

// 抛出异常
throw new AppException(ErrorCode::USER_NOT_FOUND, '用户不存在');

// 使用静态工厂方法
throw AppException::auth('登录已过期');
throw AppException::forbidden('无权访问');
throw AppException::validation(['username' => '用户名格式错误']);
throw AppException::notFound('小说');
```

### 预定义异常类

- `AuthenticationException` - 认证异常
- `AuthorizationException` - 权限异常
- `ValidationException` - 验证异常
- `NotFoundException` - 资源不存在异常
- `RateLimitException` - 速率限制异常
- `SecurityException` - 安全异常
- `CsrfException` - CSRF异常
- `XssException` - XSS异常
- `BusinessException` - 业务异常
- `AIServiceException` - AI服务异常
- `PaymentException` - 支付异常

### 辅助函数

```php
// 返回错误响应
error_response(ErrorCode::USER_NOT_FOUND);

// 返回JSON响应
json_response($data, 0, 'success');
```

---

## CSRF/XSS安全防护

### CSRF防护

#### 在表单中使用

```php
// 生成隐藏字段
echo csrf_field();

// 输出: <input type="hidden" name="_csrf_token" value="...">
```

#### 在AJAX中使用

```php
// 在HTML头部输出Meta标签
echo csrf_meta();

// 输出: <meta name="csrf-token" content="...">
```

```javascript
// AJAX请求时携带Token
fetch('/api/endpoint', {
    method: 'POST',
    headers: {
        'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').content
    },
    body: JSON.stringify(data)
});
```

#### 手动验证

```php
use Core\Security\CsrfMiddleware;

// 验证Token
if (!CsrfMiddleware::validate($token)) {
    throw new \Core\Exceptions\CsrfException();
}
```

### XSS防护

#### 清理输入

```php
use Core\Security\XssMiddleware;

$xss = new XssMiddleware();

// 清理字符串
$clean = $xss->clean($dirtyInput);

// 清理数组
$cleanArray = $xss->cleanArray($dirtyArray);

// 检测XSS
if ($xss->detectXss($input)) {
    // 发现XSS攻击
}
```

#### 输出转义

```php
use Core\Security\XssMiddleware;

// HTML转义
echo XssMiddleware::escape($userInput);

// 属性转义
echo XssMiddleware::escapeAttribute($value);

// JavaScript转义
echo XssMiddleware::escapeJs($value);

// URL转义
echo XssMiddleware::escapeUrl($value);

// CSS转义
echo XssMiddleware::escapeCss($value);
```

#### 过滤HTML

```php
// 保留安全标签
$clean = XssMiddleware::filterHtml($input, ['p', 'br', 'strong', 'em', 'a']);
```

#### 验证URL

```php
if (!XssMiddleware::isSafeUrl($url)) {
    // URL不安全
}
```

### 辅助函数

```php
// 获取CSRF Token
$token = csrf_token();

// 生成CSRF字段
echo csrf_field();

// XSS清理
$clean = xss_clean($dirty);

// HTML转义（简写）
echo e($value);
```

---

## 事件系统

### 概述

事件系统位于 `core/Events/` 目录，实现观察者模式，支持事件分发和监听。

### 触发事件

```php
use Core\Events\Events;

// 使用辅助函数
event(Events::USER_REGISTERED, [
    'id' => $userId,
    'username' => $username,
    'email' => $email,
]);

// 使用事件分发器
app('events')->fire(Events::USER_LOGIN, ['user_id' => $userId]);
```

### 创建事件订阅者

```php
use Core\Events\SubscriberInterface;
use Core\Events\Event;
use Core\Events\Events;

class UserEventSubscriber implements SubscriberInterface
{
    public function getSubscribedEvents(): array
    {
        return [
            Events::USER_REGISTERED => 'onUserRegistered',
            Events::USER_LOGIN => 'onUserLogin',
        ];
    }
    
    public function onUserRegistered(Event $event): void
    {
        $user = $event->getData();
        // 处理用户注册事件
    }
    
    public function onUserLogin(Event $event): void
    {
        $user = $event->getData();
        // 处理用户登录事件
    }
}
```

### 注册订阅者

```php
// 在 EventServiceProvider 中注册
$dispatcher->subscribe(new UserEventSubscriber());
```

### 添加监听器

```php
// 闭包监听器
app('events')->listen('user.registered', function ($event) {
    // 处理事件
});

// 类监听器
app('events')->listen('user.registered', UserRegisteredListener::class);

// 带优先级的监听器
app('events')->listen('user.registered', $listener, 10);
```

### 预定义事件

```php
// 用户事件
Events::USER_REGISTERED    // user.registered
Events::USER_LOGIN         // user.login
Events::USER_LOGOUT        // user.logout
Events::USER_UPDATED       // user.updated
Events::USER_DELETED       // user.deleted

// 小说事件
Events::NOVEL_CREATED      // novel.created
Events::NOVEL_UPDATED      // novel.updated
Events::NOVEL_PUBLISHED    // novel.published
Events::NOVEL_DELETED      // novel.deleted
Events::CHAPTER_CREATED    // novel.chapter.created

// AI事件
Events::AI_GENERATION_STARTED   // ai.generation.started
Events::AI_GENERATION_COMPLETED // ai.generation.completed
Events::AI_GENERATION_FAILED    // ai.generation.failed
Events::AI_TOKEN_CONSUMED       // ai.token.consumed

// 支付事件
Events::PAYMENT_CREATED   // payment.created
Events::PAYMENT_SUCCESS   // payment.success
Events::PAYMENT_FAILED    // payment.failed
Events::PAYMENT_REFUNDED  // payment.refunded

// 会员事件
Events::VIP_PURCHASED  // vip.purchased
Events::VIP_RENEWED    // vip.renewed
Events::VIP_EXPIRED    // vip.expired
Events::VIP_CANCELLED  // vip.cancelled

// 系统事件
Events::SYSTEM_STARTUP    // system.startup
Events::SYSTEM_SHUTDOWN   // system.shutdown
Events::SYSTEM_ERROR      // system.error
Events::SYSTEM_MAINTENANCE // system.maintenance
```

---

## 消息队列服务

### 概述

消息队列服务位于 `core/Queue/` 目录，支持异步任务处理、延迟任务和重试机制。

### 创建任务

```php
use Core\Queue\Job;
use Core\Queue\JobInterface;

class SendEmailJob extends Job implements JobInterface
{
    protected int $maxTries = 3;
    protected int $timeout = 60;
    
    public function handle(): void
    {
        $to = $this->data['to'];
        $subject = $this->data['subject'];
        $content = $this->data['content'];
        
        // 执行任务逻辑
        send_system_mail($to, $subject, $content);
    }
    
    public function failed(\Throwable $e): void
    {
        // 任务失败处理
        error_log("邮件发送失败: " . $e->getMessage());
    }
}
```

### 推送任务

```php
// 立即执行
queue(SendEmailJob::class, [
    'to' => 'user@example.com',
    'subject' => '欢迎注册',
    'content' => '欢迎加入我们！',
]);

// 指定队列
queue(SendEmailJob::class, $data, 'emails');

// 延迟执行（5分钟后）
queue_later(300, SendEmailJob::class, $data);

// 使用队列服务
app('queue')->push(SendEmailJob::class, $data);
app('queue')->later(60, SendEmailJob::class, $data, 'emails');
```

### 使用 Queueable Trait

```php
use Core\Queue\Queueable;

class ProcessData
{
    use Queueable;
    
    public function __construct(array $data)
    {
        $this->data = $data;
    }
    
    public function handle(): void
    {
        // 处理数据
    }
}

// 分发任务
$job = new ProcessData($data);
$job->onQueue('processing')->delay(60)->dispatch();
```

### 运行队列工作进程

```bash
# 基本用法
php scripts/queue_worker.php

# 指定队列
php scripts/queue_worker.php emails

# 设置休眠间隔和最大任务数
php scripts/queue_worker.php default --sleep=2 --max_jobs=100

# 设置内存限制
php scripts/queue_worker.php default --memory=256

# 单次执行
php scripts/queue_worker.php default --once

# 详细输出
php scripts/queue_worker.php default --verbose
```

### 队列管理

```php
$queue = app('queue');

// 获取队列大小
$size = $queue->size('default');

// 获取失败任务数量
$failedCount = $queue->failedCount();

// 重试失败任务
$queue->retry($failedJobId);

// 清空队列
$queue->clear('default');
```

---

## 服务提供者

服务提供者用于注册和启动服务。

### 创建服务提供者

```php
use Core\Container\ServiceProviderInterface;
use Core\Container\Container;

class MyServiceProvider implements ServiceProviderInterface
{
    public function register(Container $container): void
    {
        // 注册服务到容器
        $container->singleton(MyService::class, function () {
            return new MyService();
        });
    }
    
    public function boot(Container $container): void
    {
        // 启动服务
    }
}
```

### 注册服务提供者

```php
$app->register(new EventServiceProvider());
$app->register(new QueueServiceProvider());
$app->register(new SecurityServiceProvider());
```

---

## 配置

在应用配置中添加相关配置：

```php
$config = [
    'debug' => true,
    'env' => 'development',
    
    // CSRF配置
    'csrf' => [
        'token_name' => '_csrf_token',
        'header_name' => 'X-CSRF-TOKEN',
        'token_length' => 32,
        'token_ttl' => 3600,
        'except_routes' => [
            '/api/webhook/*',
        ],
    ],
    
    // XSS配置
    'xss' => [
        'strict_mode' => false,
        'auto_clean' => true,
    ],
    
    // 队列配置
    'queue' => [
        'default_queue' => 'default',
        'max_tries' => 3,
        'retry_delay' => 60,
        'timeout' => 300,
    ],
];
```

---

## 最佳实践

1. **错误处理**：使用统一的错误码和异常类，便于错误追踪和前端处理。

2. **安全防护**：
   - 所有表单都应包含CSRF Token
   - 所有用户输入都应进行XSS清理
   - 输出时使用转义函数

3. **事件系统**：
   - 使用事件解耦业务逻辑
   - 避免在事件处理器中执行耗时操作
   - 耗时操作应放入队列

4. **消息队列**：
   - 耗时任务放入队列异步处理
   - 设置合理的重试次数和超时时间
   - 监控队列状态和失败任务
